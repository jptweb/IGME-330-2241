{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://web-audio-hw-2/./src/audio.ts","webpack://web-audio-hw-2/./src/canvas.ts","webpack://web-audio-hw-2/./src/utils.ts","webpack://web-audio-hw-2/./src/main.ts","webpack://web-audio-hw-2/./src/loader.ts"],"sourcesContent":["// 1 - our WebAudio context, **we will export and make this public at the bottom of the file**\r\nlet audioCtx;\r\n\r\n// **These are \"private\" properties - these will NOT be visible outside of this module (i.e. file)**\r\n// 2 - WebAudio nodes that are part of our WebAudio audio routing graph\r\nlet element, sourceNode, analyserNode, gainNode;\r\n\r\n// 3 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n    gain        :   .5,\r\n    numSamples  :   256\r\n});\r\n\r\n// 4 - create a new array of 8-bit integers (0-255)\r\n// this is a typed array to hold the audio frequency data\r\nlet audioData = new Uint8Array(DEFAULTS.numSamples/2);\r\n\r\n// **Next are \"public\" methods - we are going to export all of these at the bottom of this file**\r\nconst setupWebaudio = (filepath) => {\r\n// 1 - The || is because WebAudio has not been standardized across browsers yet\r\n    const AudioContext = window.AudioContext;\r\n    audioCtx = new AudioContext;\r\n\r\n// 2 - this creates an <audio> element\r\n    element = new Audio();\r\n\r\n// 3 - have it point at a sound file\r\n    loadSoundFile(filepath);\r\n\r\n// 4 - create an a source node that points at the <audio> element\r\n    sourceNode = audioCtx.createMediaElementSource(element);\r\n\r\n// 5 - create an analyser node\r\n    analyserNode = audioCtx.createAnalyser();// note the UK spelling of \"Analyser\"\r\n\r\n/*\r\n// 6\r\nWe will request DEFAULTS.numSamples number of samples or \"bins\" spaced equally \r\nacross the sound spectrum.\r\n\r\nIf DEFAULTS.numSamples (fftSize) is 256, then the first bin is 0 Hz, the second is 172 Hz, \r\nthe third is 344Hz, and so on. Each bin contains a number between 0-255 representing \r\nthe amplitude of that frequency.\r\n*/ \r\n\r\n// fft stands for Fast Fourier Transform\r\n    analyserNode.fftSize = DEFAULTS.numSamples;\r\n\r\n// 7 - create a gain (volume) node\r\n    gainNode = audioCtx.createGain();\r\n    gainNode.gain.value = DEFAULTS.gain;\r\n\r\n// 8 - connect the nodes - we now have an audio graph\r\n    sourceNode.connect(analyserNode);\r\n    analyserNode.connect(gainNode);\r\n    gainNode.connect(audioCtx.destination);\r\n}\r\n\r\nconst loadSoundFile = (filepath) => {\r\n    element.src = filepath;\r\n}\r\n\r\nconst playCurrentSound = () => {\r\n    element.play();\r\n}\r\n\r\nconst pauseCurrentSound = () => {\r\n    element.pause();\r\n}\r\n\r\nconst setVolume = (value) => {\r\n    value = Number(value);\r\n    gainNode.gain.value = value;\r\n}\r\n\r\nexport {audioCtx,setupWebaudio,playCurrentSound,pauseCurrentSound,loadSoundFile,setVolume,analyserNode};\r\n// make sure that it's a Number rather than a String","/*\r\n\tThe purpose of this file is to take in the analyser node and a <canvas> element: \r\n\t  - the module will create a drawing context that points at the <canvas> \r\n\t  - it will store the reference to the analyser node\r\n\t  - in draw(), it will loop through the data in the analyser node\r\n\t  - and then draw something representative on the canvas\r\n\t  - maybe a better name for this file/module would be *visualizer.js* ?\r\n*/\r\n\r\nimport * as utils from './utils';\r\n\r\nlet ctx,canvasWidth,canvasHeight,gradient,analyserNode,audioData;\r\n\r\ninterface DrawParams{\r\n    showGradient: boolean,\r\n    showBars: boolean,\r\n    showCircles: boolean,\r\n    showNoise: boolean,\r\n    showInvert: boolean,\r\n    showEmboss: boolean\r\n\r\n  }\r\n\r\nconst setupCanvas = (canvasElement,analyserNodeRef) => {\r\n\t// create drawing context\r\n\tctx = canvasElement.getContext(\"2d\");\r\n\tcanvasWidth = canvasElement.width;\r\n\tcanvasHeight = canvasElement.height;\r\n\t// create a gradient that runs top to bottom\r\n\tgradient = utils.getLinearGradient(ctx,0,0,0,canvasHeight,[{percent:0,color:\"#247c82\"},{percent:.40,color:\"#6e98db\"},{percent:.6,color:\"#5aad88\"},{percent:1,color:\"#248258\"}]);\r\n\t// keep a reference to the analyser node\r\n\tanalyserNode = analyserNodeRef;\r\n\t// this is the array where the analyser data will be stored\r\n\taudioData = new Uint8Array(analyserNode.fftSize/2);\r\n}\r\n\r\nconst draw = (params:DrawParams) => {\r\n  // 1 - populate the audioData array with the frequency data from the analyserNode\r\n\t// notice these arrays are passed \"by reference\" \r\n\tanalyserNode.getByteFrequencyData(audioData);\r\n\t// OR\r\n\t//analyserNode.getByteTimeDomainData(audioData); // waveform data\r\n\t\r\n\t// 2 - draw background\r\n\tctx.save();\r\n    ctx.fillStyle = \"black\";\r\n    ctx.globalAlpha = .1;\r\n    ctx.fillRect(0,0,canvasWidth,canvasHeight);\r\n    ctx.restore();\r\n\t\t\r\n\t// 3 - draw gradient\r\n\tif(params.showGradient){\r\n        ctx.save();\r\n        ctx.fillStyle = gradient;\r\n        ctx.globalAlpha = .3;\r\n        ctx.fillRect(0,0,canvasWidth,canvasHeight);\r\n        ctx.restore();\r\n    }\r\n\t// 4 - draw bars\r\n\tif(params.showBars){\r\n        let barSpacing = 4;\r\n        let margin = 5;\r\n        let screenWidthForBars = canvasWidth - (audioData.length * barSpacing) - margin * 2;\r\n        let barWidth = screenWidthForBars / audioData.length;\r\n        let barHeight = 200;\r\n        let topSpacing = 100;\r\n\r\n        ctx.save();\r\n        ctx.fillStyle = 'rgba(255,255,255,0.50)';\r\n        ctx.strokeStyle = 'rgba(0,0,0,0.50)';\r\n        //loop through and draw\r\n        for(let i = 0; i < audioData.length; i++){\r\n            ctx.fillRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth,barHeight);\r\n            ctx.strokeRect(margin + i * (barWidth + barSpacing), topSpacing + 256 - audioData[i], barWidth,barHeight);\r\n        }\r\n        ctx.restore();\r\n    }\r\n\t// 5 - draw circles\r\n\tif(params.showCircles){\r\n        let maxRadius = canvasHeight / 4;\r\n        ctx.save();\r\n        ctx.globalAlpha = 0.5;\r\n        for(let i = 0; i < audioData.length; i++) {\r\n            //red-ish circles\r\n            let percent = audioData[i] / 255;\r\n\r\n            let circleRadius = percent * maxRadius;\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(255, 111, 111, .35 - percent/3.0);\r\n            ctx.arc(canvasWidth/2, canvasHeight/2, circleRadius, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            //blue-ish circles\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(0,0,255, .10 - percent/10.0);\r\n            ctx.arc(canvasWidth/2,canvasHeight/2, circleRadius * 1.5, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n\r\n            //yellowish\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.fillStyle = utils.makeColor(200,200,0,.5 - percent/5.0);\r\n            ctx.arc(canvasWidth/2,canvasHeight/2, circleRadius * .5, 0, 2 * Math.PI, false);\r\n            ctx.fill();\r\n            ctx.closePath();\r\n            ctx.restore();\r\n        }\r\n        ctx.restore();\r\n    }\r\n    // 6 - bitmap manipulation\r\n\t// TODO: right now. we are looping though every pixel of the canvas (320,000 of them!), \r\n\t// regardless of whether or not we are applying a pixel effect\r\n\t// At some point, refactor this code so that we are looping though the image data only if\r\n\t// it is necessary\r\n\r\n\t// A) grab all of the pixels on the canvas and put them in the `data` array\r\n\t// `imageData.data` is a `Uint8ClampedArray()` typed array that has 1.28 million elements!\r\n\t// the variable `data` below is a reference to that array \r\n\tlet imageData = ctx.getImageData(0,0,canvasWidth,canvasHeight);\r\n    let data = imageData.data;\r\n    let length = data.length;\r\n    let width = imageData.width;//not using here\r\n\t// B) Iterate through each pixel, stepping 4 elements at a time (which is the RGBA for 1 pixel)\r\n    for(let i = 0; i < length; i += 4){\r\n\t\t// C) randomly change every 20th pixel to red\r\n        if(params.showNoise && Math.random() < .05){\r\n\t\t\t// data[i] is the red channel\r\n\t\t\t// data[i+1] is the green channel\r\n\t\t\t// data[i+2] is the blue channel\r\n\t\t\t// data[i+3] is the alpha channel\r\n\t\t\t//data[i] = data[i + 1] = data[i + 2] = 0; // zero out the red and green and blue channels\r\n\t\t\tdata[i] = 67;\r\n            data[i + 1] = 36;\r\n            data[i + 2] = 130; // Noise is now a dark purple\r\n\t\t} // end if\r\n        //invert?\r\n        if(params.showInvert){\r\n            let red = data[i], green = data[i+1], blue = data[i+2];\r\n            data[i] = 255 - red; //set red\r\n            data[i+1] = 255 - green; //set green\r\n            data[i+2] = 255 - blue; //set blue\r\n            //data[i+3] is alpha\r\n        }\r\n\t} // end for\r\n\t//Step through sub pixels\r\n    if(params.showEmboss)\r\n    {\r\n        for(let i = 0; i < length; i++)\r\n        {\r\n            if (i%4 == 3) continue; //skip alpha channel\r\n            data[i] = 127 + 2 * data[i] - data[i + 4] - data [i + width * 4];\r\n        }\r\n    }\r\n\t// D) copy image data back to canvas\r\n    ctx.putImageData(imageData,0,0);\r\n}\r\n\r\nexport {setupCanvas,draw};","const makeColor = (red, green, blue, alpha = 1) => {\r\n    return `rgba(${red},${green},${blue},${alpha})`;\r\n  };\r\n  \r\n  const getRandom = (min, max) => {\r\n    return Math.random() * (max - min) + min;\r\n  };\r\n  \r\n  const getRandomColor = () => {\r\n    const floor = 35; // so that colors are not too bright or too dark \r\n    const getByte = () => getRandom(floor,255-floor);\r\n    return `rgba(${getByte()},${getByte()},${getByte()},1)`;\r\n  };\r\n  \r\n  const getLinearGradient = (ctx,startX,startY,endX,endY,colorStops) => {\r\n    let lg = ctx.createLinearGradient(startX,startY,endX,endY);\r\n    for(let stop of colorStops){\r\n      lg.addColorStop(stop.percent,stop.color);\r\n    }\r\n    return lg;\r\n  };\r\n  \r\n  // https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API\r\n  const goFullscreen = (element) => {\r\n    if (element.requestFullscreen) {\r\n      element.requestFullscreen();\r\n    } else if (element.mozRequestFullscreen) {\r\n      element.mozRequestFullscreen();\r\n    } else if (element.mozRequestFullScreen) { // camel-cased 'S' was changed to 's' in spec\r\n      element.mozRequestFullScreen();\r\n    } else if (element.webkitRequestFullscreen) {\r\n      element.webkitRequestFullscreen();\r\n    }\r\n    // .. and do nothing if the method is not supported\r\n  };\r\n  \r\n  export {makeColor, getRandomColor, getLinearGradient, goFullscreen};","/*\r\n\tmain.js is primarily responsible for hooking up the UI to the rest of the application \r\n\tand setting up the main event loop\r\n*/\r\n\r\n// We will write the functions in this file in the traditional ES5 way\r\n// In this instance, we feel the code is more readable if written this way\r\n// If you want to re-write these as ES6 arrow functions, to be consistent with the other files, go ahead!\r\nimport * as audio from './audio';\r\nimport * as utils from './utils';\r\nimport * as canvas from './canvas';\r\n\r\nconst drawParams = {\r\n  showGradient  :true,\r\n  showBars      :true,\r\n  showCircles   :true,\r\n  showNoise     :false,\r\n  showInvert    :false,\r\n  showEmboss    :false\r\n};\r\n// 1 - here we are faking an enumeration\r\nconst DEFAULTS = Object.freeze({\r\n\tsound1  :  \"media/New Adventure Theme.mp3\"\r\n});\r\n\r\nfunction init(){\r\n\tconsole.log(\"init called\");\r\n\tconsole.log(`Testing utils.getRandomColor() import: ${utils.getRandomColor()}`);\r\n  audio.setupWebaudio(DEFAULTS.sound1);\r\n\tlet canvasElement = document.querySelector(\"canvas\"); // hookup <canvas> element\r\n\tsetupUI(canvasElement);\r\n  canvas.setupCanvas(canvasElement,audio.analyserNode);\r\n  loop();\r\n}\r\n\r\nfunction setupUI(canvasElement){\r\n  // A - hookup fullscreen button\r\n  const fsButton = document.querySelector(\"#fsButton\") as HTMLButtonElement;\r\n  // add .onclick event to button\r\n  fsButton.onclick = e => {\r\n    console.log(\"goFullscreen() called\");\r\n    utils.goFullscreen(canvasElement);\r\n  };\r\n  const playButton = document.querySelector(\"#playButton\") as HTMLElement;\r\n\tplayButton.onclick = e => {\r\n    console.log(`audioCtx.state before = ${audio.audioCtx.state}`);\r\n    //check if context is in suspended state\r\n    if(audio.audioCtx.state == \"suspended\") {\r\n      audio.audioCtx.resume();\r\n    }\r\n    console.log(`audioCtx.state after = ${audio.audioCtx.state}`);\r\n\r\n    const target = e.target as HTMLInputElement;\r\n    if(target.dataset.playing == \"no\"){\r\n      //if track is currently paused, play it\r\n      audio.playCurrentSound();\r\n      target.dataset.playing = \"yes\";//Our CSS will set the text to Pause\r\n      //if track is playing, pause it\r\n    }else{\r\n      audio.pauseCurrentSound();\r\n      target.dataset.playing = \"no\"; //CSS sets to play\r\n    }\r\n  };\r\n  //C - hookup volume slider and label\r\n  let volumeSlider = document.querySelector(\"#volumeSlider\") as HTMLInputElement;\r\n  let volumeLabel = document.querySelector(\"#volumeLabel\") as HTMLSpanElement;\r\n  //add .oninput event to slider\r\n  volumeSlider.oninput = e => {\r\n    //set the gain\r\n    const target = e.target as HTMLInputElement;\r\n\r\n    audio.setVolume(target.value);\r\n    //update value of label to match value of slider\r\n    volumeLabel.innerHTML = (Math.round((parseInt(target.value)/2 * 100))).toString();\r\n  };\r\n\r\n  //set value of label to match inital value of slider\r\n  volumeSlider.dispatchEvent(new Event(\"input\"));\r\n\r\n  //D - hookup track <select>\r\n  let trackSelect = document.querySelector(\"#trackSelect\") as HTMLSelectElement;\r\n  // add .onchange event to <select>\r\n  trackSelect.onchange = e => {\r\n    const target = e.target as HTMLInputElement;\r\n    audio.loadSoundFile(target.value);\r\n    //pause the current track if it is playing\r\n    if(playButton.dataset.playing == \"yes\"){\r\n      playButton.dispatchEvent(new MouseEvent(\"click\"));\r\n    }\r\n  }\r\n\r\n  let gradientCB = document.querySelector(\"#gradientCB\") as HTMLInputElement;\r\n  let barsCB = document.querySelector(\"#barsCB\") as HTMLInputElement;\r\n  let circlesCB = document.querySelector(\"#circlesCB\") as HTMLInputElement;\r\n  gradientCB.checked = true;\r\n  gradientCB.onchange = e =>\r\n  {\r\n    drawParams.showGradient = gradientCB.checked;\r\n  }\r\n  barsCB.checked = true;\r\n  barsCB.onchange = e =>\r\n  {\r\n    drawParams.showBars = barsCB.checked;\r\n  }\r\n  circlesCB.checked = true;\r\n  circlesCB.onchange = e =>\r\n  {\r\n    drawParams.showCircles = circlesCB.checked;\r\n  }\r\n  const noiseCB = document.querySelector(\"#noiseCB\") as HTMLInputElement;\r\n  noiseCB.onchange = e =>\r\n  {\r\n    drawParams.showNoise = noiseCB.checked;\r\n  }\r\n  const invertCB = document.querySelector(\"#invertCB\") as HTMLInputElement;\r\n  invertCB.onchange = e =>\r\n  {\r\n    drawParams.showInvert = invertCB.checked;\r\n  }\r\n  const embossCB = document.querySelector(\"#embossCB\") as HTMLInputElement;\r\n  embossCB.onchange = e =>\r\n  {\r\n    drawParams.showEmboss = embossCB.checked;\r\n  }\r\n} // end setupUI\r\n\r\n\r\nfunction loop(){\r\n    requestAnimationFrame(loop);\r\n    canvas.draw(drawParams);\r\n}\r\nexport {init};","import * as main from \"./main\";\r\nwindow.onload = ()=>{\r\n\tconsole.log(\"window.onload called\");\r\n\t// 1 - do preload here - load fonts, images, additional sounds, etc...\r\n\t\r\n\t// 2 - start up app\r\n\tmain.init();\r\n}"],"names":["audioCtx","sourceNode","analyserNode","gainNode","ctx","canvasWidth","canvasHeight","gradient","DEFAULTS","Object","freeze","gain","numSamples","loadSoundFile","Uint8Array","filepath","src","makeColor","red","green","blue","alpha","drawParams","showGradient","showBars","showCircles","showNoise","showInvert","showEmboss","sound1","init","AudioContext","getByte","console","log","Math","random","window","Audio","createMediaElementSource","createAnalyser","fftSize","createGain","value","connect","destination","canvasElement","document","querySelector","onclick","e","element","requestFullscreen","mozRequestFullscreen","mozRequestFullScreen","webkitRequestFullscreen","playButton","state","resume","target","dataset","playing","play","pause","volumeSlider","volumeLabel","oninput","Number","innerHTML","round","parseInt","toString","dispatchEvent","Event","onchange","MouseEvent","gradientCB","barsCB","circlesCB","checked","noiseCB","invertCB","embossCB","setupUI","analyserNodeRef","getContext","width","height","startX","startY","endX","endY","lg","createLinearGradient","percent","color","addColorStop","loop","requestAnimationFrame","params","getByteFrequencyData","save","fillStyle","globalAlpha","fillRect","restore","barWidth","length","margin","strokeStyle","i","topSpacing","strokeRect","maxRadius","circleRadius","beginPath","arc","PI","fill","closePath","imageData","getImageData","data","putImageData","onload"],"sourceRoot":""}